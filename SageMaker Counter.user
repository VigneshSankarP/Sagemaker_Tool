// ==UserScript==
// @name         SageMaker Counter
// @namespace    http://tampermonkey.net/
// @version      15.7
// @description  Counter + Reset styled like "Decline Task" (AWS pattern) with correctly fitted button width based on inner text. Draggable, persistent, and auto-counting for SageMaker labeling UI.
// @author       PVSANKAR
// @match        *://*.sagemaker.aws/*
// @noframes
// @grant        none
// @run-at       document-end
// @updateURL    https://raw.githubusercontent.com/VigneshSankarP/Sagemaker-Counter/main/SageMaker%20Counter.user.js
// @downloadURL  https://raw.githubusercontent.com/VigneshSankarP/Sagemaker-Counter/main/SageMaker%20Counter.user.js
// ==/UserScript==


(() => {
  'use strict';

  if (window !== window.top) return;

  const CONFIG = {
    POS_KEY: 'sm_counter_pos',
    COUNT_KEY: 'sm_count'
  };

  // ---------- Local storage ----------
  const store = {
    get(key, fallback) {
      try {
        const value = localStorage.getItem(key);
        return value ? JSON.parse(value) : fallback;
      } catch {
        return fallback;
      }
    },
    set(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch {}
    }
  };

  // ---------- Find Decline Task button ----------
  function findDeclineButton() {
    const selectors = [
      'button[data-testid="decline-task-button"]',
      'button.awsui-button',
      'button'
    ];
    for (const sel of selectors) {
      for (const b of document.querySelectorAll(sel)) {
        if (/decline\s*task/i.test(b.textContent || '')) return b;
      }
    }
    return null;
  }

  // ---------- Clone Decline Task visual pattern but allow natural sizing ----------
  function applyDeclinePattern(targetBtn) {
    const decline = findDeclineButton();
    if (!decline) return;

    const computed = getComputedStyle(decline);
    const allowedProps = [
      'color', 'background-color', 'border', 'border-radius',
      'font-family', 'font-size', 'font-weight', 'line-height',
      'text-transform', 'letter-spacing', 'cursor',
      'box-shadow', 'transition', 'outline'
    ];

    for (const prop of allowedProps) {
      try {
        targetBtn.style.setProperty(prop, computed.getPropertyValue(prop), computed.getPropertyPriority(prop));
      } catch {}
    }

    // âœ… make it naturally fit its content
    targetBtn.style.display = 'inline-flex';
    targetBtn.style.alignItems = 'center';
    targetBtn.style.justifyContent = 'center';
    targetBtn.style.padding = computed.padding || '0 12px';
    targetBtn.style.height = computed.height || '28px';
    targetBtn.style.whiteSpace = 'nowrap';
    targetBtn.style.minWidth = 'fit-content';
    targetBtn.style.width = 'auto';
  }

  // ---------- UI Creation ----------
  function createCounterUI() {
    if (document.getElementById('sm-counter-wrap')) return;

    const wrap = document.createElement('div');
    wrap.id = 'sm-counter-wrap';
    Object.assign(wrap.style, {
      position: 'fixed',
      top: '80px',
      left: '80px',
      display: 'flex',
      gap: '6px',
      alignItems: 'center',
      zIndex: '999999',
      cursor: 'grab',
      userSelect: 'none'
    });

    const counter = document.createElement('button');
    counter.id = 'sm-counter-btn';
    counter.textContent = `Count : ${store.get(CONFIG.COUNT_KEY, 0)}`;

    const reset = document.createElement('button');
    reset.textContent = 'Reset';

    wrap.append(counter, reset);
    document.body.appendChild(wrap);

    // Apply Decline Task visual pattern once available
    const tryStyle = () => {
      const decline = findDeclineButton();
      if (decline) {
        applyDeclinePattern(counter);
        applyDeclinePattern(reset);
        return true;
      }
      return false;
    };

    if (!tryStyle()) {
      const obs = new MutationObserver(() => {
        if (tryStyle()) obs.disconnect();
      });
      obs.observe(document.body, { childList: true, subtree: true });
    }

    // Reset logic
    reset.onclick = () => {
      store.set(CONFIG.COUNT_KEY, 0);
      counter.textContent = 'Count : 0';
    };

    // ---------- Position near Decline Task ----------
    const tryAttach = () => {
      const decline = findDeclineButton();
      if (decline && document.body.contains(decline)) {
        const rect = decline.getBoundingClientRect();
        wrap.style.top = `${window.scrollY + rect.top}px`;
        wrap.style.left = `${Math.max(0, window.scrollX + rect.left - 180)}px`;
        return true;
      }
      return false;
    };

    if (!tryAttach()) {
      let timer = null;
      const observer = new MutationObserver(() => {
        if (timer) return;
        timer = setTimeout(() => {
          timer = null;
          if (tryAttach()) observer.disconnect();
        }, 300);
      });
      observer.observe(document.body, { childList: true, subtree: true });
    }

    // ---------- Dragging ----------
    let dragging = false, dx = 0, dy = 0;
    wrap.addEventListener('mousedown', e => {
      if (e.target.tagName === 'BUTTON') return;
      const rect = wrap.getBoundingClientRect();
      dx = e.clientX - rect.left;
      dy = e.clientY - rect.top;
      dragging = true;
      wrap.style.cursor = 'grabbing';
      e.preventDefault();
    });

    document.addEventListener('mousemove', e => {
      if (!dragging) return;
      const vw = window.innerWidth, vh = window.innerHeight;
      const elW = wrap.offsetWidth, elH = wrap.offsetHeight;
      let newLeft = e.clientX - dx, newTop = e.clientY - dy;
      newLeft = Math.max(0, Math.min(vw - elW, newLeft));
      newTop = Math.max(0, Math.min(vh - elH, newTop));
      wrap.style.left = `${newLeft}px`;
      wrap.style.top = `${newTop}px`;
    }, { passive: true });

    document.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = false;
      wrap.style.cursor = 'grab';
      store.set(CONFIG.POS_KEY, { top: wrap.style.top, left: wrap.style.left });
    }, { passive: true });
  }

  // ---------- Count Logic ----------
  let lastIncrement = 0;
  function bump() {
    const newCount = store.get(CONFIG.COUNT_KEY, 0) + 1;
    store.set(CONFIG.COUNT_KEY, newCount);
    const btn = document.getElementById('sm-counter-btn');
    if (btn) btn.textContent = `Count : ${newCount}`;
  }

  const shouldCount = (url, method, status) =>
    url && method && method.toUpperCase() === 'POST' &&
    status === 200 &&
    /\/tasks\/[^/]+\/submit-and-start-next/i.test(url);

  const countOnce = () => {
    const now = Date.now();
    if (now - lastIncrement >= 800) {
      lastIncrement = now;
      bump();
    }
  };

  // ---------- Network intercept ----------
  const _fetch = window.fetch;
  window.fetch = async function (...args) {
    const input = args[0];
    let url = '', method = 'GET';
    if (typeof input === 'string') url = input;
    else if (input && input.url) url = input.url;
    if (args[1]?.method) method = args[1].method;

    const res = await _fetch.apply(this, args);
    try { if (shouldCount(url, method, res.status)) countOnce(); } catch {}
    return res;
  };

  const _open = XMLHttpRequest.prototype.open;
  const _send = XMLHttpRequest.prototype.send;
  const xhrMeta = new WeakMap();
  XMLHttpRequest.prototype.open = function (method, url, async, user, pass) {
    xhrMeta.set(this, { method, url });
    return _open.apply(this, arguments);
  };
  XMLHttpRequest.prototype.send = function (body) {
    this.addEventListener('loadend', function () {
      const meta = xhrMeta.get(this);
      try { if (meta && shouldCount(meta.url, meta.method, this.status)) countOnce(); } catch {}
    });
    return _send.apply(this, arguments);
  };

  // ---------- Init ----------
  const init = () => {
    if (!document.body) return setTimeout(init, 100);
    createCounterUI();
  };

  if (document.readyState === 'loading')
    document.addEventListener('DOMContentLoaded', init, { once: true });
  else
    init();
})();
